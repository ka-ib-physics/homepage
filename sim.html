<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Position–Time to Velocity–Time Simulator</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
    }

    p.description {
      max-width: 800px;
      margin: 0 auto 20px;
      text-align: center;
      font-size: 0.95rem;
      color: #555;
    }

    .container {
      max-width: 840px;
      margin: 0 auto;
      background: #fff;
      padding: 16px 16px 24px;
      border-radius: 12px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.08);
    }

    .canvas-wrapper {
      margin-bottom: 16px;
    }

    .canvas-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 4px;
    }

    .canvas-header h2 {
      font-size: 1.05rem;
      margin: 0;
    }

    .canvas-header span {
      font-size: 0.8rem;
      color: #777;
    }

    canvas {
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fafafa;
      cursor: crosshair;
      display: block;
    }

    #velocityCanvas {
      cursor: default;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
      margin: 10px 0 18px;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 8px 16px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #2563eb;
      color: white;
      font-weight: 500;
      box-shadow: 0 2px 6px rgba(37,99,235,0.25);
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease;
    }

    button.secondary {
      background: #e5e7eb;
      color: #111827;
      box-shadow: none;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(37,99,235,0.3);
    }

    button.secondary:hover {
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }

    .slider-group {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-size: 0.8rem;
      color: #374151;
    }

    .slider-group label {
      margin-bottom: 2px;
    }

    input[type="range"] {
      width: 180px;
    }

    .hint {
      font-size: 0.8rem;
      color: #6b7280;
      text-align: center;
      margin-top: 4px;
    }

    .legend {
      font-size: 0.8rem;
      color: #6b7280;
      text-align: right;
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <h1>Position–Time → Velocity–Time</h1>
  <p class="description">
    Draw any position–time graph in the top canvas with your mouse. Then click
    <strong>Compute Velocity</strong> to see an approximate velocity–time graph below.
  </p>

  <div class="container">
    <div class="canvas-wrapper">
      <div class="canvas-header">
        <h2>Position vs Time</h2>
        <span>Horizontal axis: time &nbsp;|&nbsp; Vertical axis: position</span>
      </div>
      <canvas id="positionCanvas" width="800" height="280"></canvas>
      <div class="legend">Draw with mouse (click &amp; drag)</div>
    </div>

    <div class="controls">
      <button id="computeBtn">Compute Velocity</button>
      <button id="clearBtn" class="secondary">Clear All</button>

      <div class="slider-group">
        <label for="smoothSlider">
          Position smoothing:
          <span id="smoothLabel"></span>
        </label>
        <input
          type="range"
          id="smoothSlider"
          min="0"
          max="4"
          step="1"
          value="2"
        />
      </div>
    </div>

    <div class="canvas-wrapper">
      <div class="canvas-header">
        <h2>Velocity vs Time</h2>
        <span>Horizontal axis: time &nbsp;|&nbsp; Vertical axis: velocity</span>
      </div>
      <canvas id="velocityCanvas" width="800" height="280"></canvas>
      <div class="legend">Resulting velocity–time graph</div>
    </div>

    <div class="hint">
      Hint: A straight, increasing line in position–time should give a constant (flat) velocity line.
    </div>
  </div>

  <script>
    // ====== BASIC SETUP ======
    const posCanvas = document.getElementById("positionCanvas");
    const posCtx = posCanvas.getContext("2d");

    const velCanvas = document.getElementById("velocityCanvas");
    const velCtx = velCanvas.getContext("2d");

    const computeBtn = document.getElementById("computeBtn");
    const clearBtn = document.getElementById("clearBtn");
    const smoothSlider = document.getElementById("smoothSlider");
    const smoothLabel = document.getElementById("smoothLabel");

    const MAX_TIME = 10; // seconds
    const N_UNIFORM = 200; // samples on uniform grid

    let posPoints = [];
    let drawing = false;

    // Smoothing presets (Savitzky–Golay + kernel bandwidth)
    let smoothingLevel = parseInt(smoothSlider.value, 10);
    const sgLevels = [
      { label: "Very light", window: 5,  bandwidth: 0.03 },
      { label: "Light",      window: 7,  bandwidth: 0.05 },
      { label: "Medium",     window: 9,  bandwidth: 0.07 },
      { label: "Strong",     window: 11, bandwidth: 0.09 },
      { label: "Max",        window: 11, bandwidth: 0.12 },
    ];

    function updateSmoothLabel() {
      const lvl = sgLevels[smoothingLevel];
      smoothLabel.textContent = lvl.label;
    }
    updateSmoothLabel();

    smoothSlider.addEventListener("input", () => {
      smoothingLevel = parseInt(smoothSlider.value, 10);
      updateSmoothLabel();
    });

    // ====== UTILS ======
    function getCanvasCoords(canvas, evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top,
      };
    }

    // Simple moving-average smoother for velocity
    function smoothArray(arr, windowSize) {
      if (arr.length <= 2 || windowSize <= 1) return arr.slice();
      const smoothed = [];
      const half = Math.floor(windowSize / 2);

      for (let i = 0; i < arr.length; i++) {
        let start = Math.max(0, i - half);
        let end = Math.min(arr.length - 1, i + half);
        let sum = 0;
        let count = 0;

        for (let j = start; j <= end; j++) {
          sum += arr[j];
          count++;
        }
        smoothed.push(sum / count);
      }
      return smoothed;
    }

    // Savitzky–Golay smoothing for position (0th derivative)
    function savitzkyGolaySmooth(data, level) {
      const n = data.length;
      if (n === 0) return [];
      const cfg = sgLevels[level] || sgLevels[0];
      const window = cfg.window;

      if (window <= 1 || n < window) {
        return data.slice();
      }

      let coeffs;
      if (window === 5) {
        coeffs = [-0.08571429, 0.34285714, 0.48571429, 0.34285714, -0.08571429];
      } else if (window === 7) {
        coeffs = [-0.09523810, 0.14285714, 0.28571429, 0.33333333, 0.28571429, 0.14285714, -0.09523810];
      } else if (window === 9) {
        coeffs = [
          -0.09090909, 0.06060606, 0.16883117, 0.23376623, 0.25541126,
          0.23376623, 0.16883117, 0.06060606, -0.09090909
        ];
      } else if (window === 11) {
        coeffs = [
          -0.08391608, 0.02097902, 0.10256410, 0.16083916, 0.19580420,
          0.20745921, 0.19580420, 0.16083916, 0.10256410, 0.02097902,
          -0.08391608
        ];
      } else {
        return data.slice();
      }

      const half = Math.floor(window / 2);
      const out = new Array(n);

      for (let i = 0; i < n; i++) {
        let acc = 0;
        for (let j = 0; j < window; j++) {
          const offset = j - half;
          let idx = i + offset;
          if (idx < 0) idx = 0;
          if (idx >= n) idx = n - 1;
          acc += coeffs[j] * data[idx];
        }
        out[i] = acc;
      }

      return out;
    }

    // Kernel smoothing: resample positions onto uniform time grid
    function kernelSmoothResample(times, positions, tUniform, bandwidth) {
      const nSamples = tUniform.length;
      const n = times.length;
      const out = new Array(nSamples);

      if (n === 0) return out.fill(0);

      const bw = bandwidth;
      const bw3 = 3 * bw;

      for (let i = 0; i < nSamples; i++) {
        const t0 = tUniform[i];
        let num = 0;
        let den = 0;

        for (let j = 0; j < n; j++) {
          const dt = times[j] - t0;
          const adt = Math.abs(dt);
          if (adt > bw3) continue;
          const w = Math.exp(-(dt * dt) / (2 * bw * bw));
          num += w * positions[j];
          den += w;
        }

        if (den === 0) {
          // fallback: nearest neighbor or previous
          if (i === 0) {
            out[i] = positions[0];
          } else {
            out[i] = out[i - 1];
          }
        } else {
          out[i] = num / den;
        }
      }

      return out;
    }

    // Draw axes & grid
    function drawAxes(ctx, canvas, options = {}) {
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      const {
        gridColor = "#e5e7eb",
        axisColor = "#111827",
        numXGrid = 10,
        numYGrid = 6,
      } = options;

      ctx.save();
      ctx.lineWidth = 1;

      ctx.strokeStyle = gridColor;
      ctx.beginPath();
      for (let i = 1; i < numXGrid; i++) {
        const x = (i / numXGrid) * w;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
      }

      for (let j = 1; j < numYGrid; j++) {
        const y = (j / numYGrid) * h;
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
      }
      ctx.stroke();

      ctx.strokeStyle = axisColor;

      ctx.beginPath();
      ctx.moveTo(0, h - 20);
      ctx.lineTo(w, h - 20);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(40, 0);
      ctx.lineTo(40, h);
      ctx.stroke();

      ctx.restore();
    }

    function redrawPosition() {
      drawAxes(posCtx, posCanvas);
      if (posPoints.length < 2) return;
      posCtx.save();
      posCtx.lineWidth = 2;
      posCtx.strokeStyle = "#2563eb";
      posCtx.beginPath();
      posPoints.forEach((p, i) => {
        if (i === 0) posCtx.moveTo(p.x, p.y);
        else posCtx.lineTo(p.x, p.y);
      });
      posCtx.stroke();
      posCtx.restore();
    }

    function clearAll() {
      posPoints = [];
      drawAxes(posCtx, posCanvas);
      drawAxes(velCtx, velCanvas);
    }

    // ====== DRAWING LOGIC ======
    posCanvas.addEventListener("mousedown", (e) => {
      drawing = true;
      const { x, y } = getCanvasCoords(posCanvas, e);
      posPoints.push({ x, y });
      redrawPosition();
    });

    posCanvas.addEventListener("mousemove", (e) => {
      if (!drawing) return;
      const { x, y } = getCanvasCoords(posCanvas, e);
      const last = posPoints[posPoints.length - 1];
      posPoints.push({ x, y });

      posCtx.save();
      posCtx.lineWidth = 2;
      posCtx.strokeStyle = "#2563eb";
      posCtx.beginPath();
      posCtx.moveTo(last.x, last.y);
      posCtx.lineTo(x, y);
      posCtx.stroke();
      posCtx.restore();
    });

    window.addEventListener("mouseup", () => {
      if (drawing) {
        drawing = false;
      }
    });

    // ====== COMPUTE VELOCITY ======
    function computeVelocity() {
      if (posPoints.length < 2) {
        alert("Draw a position–time graph first.");
        return;
      }

      // 1. Sort by time (x)
      let pts = posPoints.slice().sort((a, b) => a.x - b.x);

      // 2. Filter points that are too close in x
      const filtered = [];
      const minDx = 4;
      for (let p of pts) {
        if (
          filtered.length === 0 ||
          Math.abs(p.x - filtered[filtered.length - 1].x) >= minDx
        ) {
          filtered.push(p);
        }
      }

      pts = filtered;
      if (pts.length < 2) {
        alert("The drawing is too short or almost vertical; try a smoother, longer curve.");
        return;
      }

      const w = posCanvas.width;
      const h = posCanvas.height;

      const times = pts.map((p) => (p.x / w) * MAX_TIME);
      const positionsRaw = pts.map((p) => (h - p.y) / h * 10); // arbitrary units

      // 3. Resample onto a uniform time grid with kernel smoothing
      const cfg = sgLevels[smoothingLevel];
      const bandwidth = cfg.bandwidth * MAX_TIME;

      const tUniform = [];
      for (let i = 0; i < N_UNIFORM; i++) {
        tUniform.push((i / (N_UNIFORM - 1)) * MAX_TIME);
      }

      const kernelSmoothed = kernelSmoothResample(
        times,
        positionsRaw,
        tUniform,
        bandwidth
      );

      // 4. Savitzky–Golay smoothing on the uniform positions
      const sgPositions = savitzkyGolaySmooth(kernelSmoothed, smoothingLevel);

      // 5. Central difference derivative on the uniform grid
      const dt = tUniform[1] - tUniform[0];
      const velocities = new Array(N_UNIFORM);

      for (let i = 0; i < N_UNIFORM; i++) {
        let v;
        if (i === 0) {
          v = (sgPositions[1] - sgPositions[0]) / dt;
        } else if (i === N_UNIFORM - 1) {
          v = (sgPositions[N_UNIFORM - 1] - sgPositions[N_UNIFORM - 2]) / dt;
        } else {
          v = (sgPositions[i + 1] - sgPositions[i - 1]) / (2 * dt);
        }
        velocities[i] = v;
      }

      // 6. Extra smoothing on velocity (small moving average)
      const smoothedVelocities = smoothArray(velocities, 7);

      drawVelocityGraph(tUniform, smoothedVelocities);
    }

    function drawVelocityGraph(times, velocities) {
      const w = velCanvas.width;
      const h = velCanvas.height;

      let minV = Math.min(...velocities);
      let maxV = Math.max(...velocities);

      if (minV === maxV) {
        const pad = Math.abs(minV) || 1;
        minV -= pad;
        maxV += pad;
      }

      const timeMax = MAX_TIME;

      function tToX(t) {
        return (t / timeMax) * (w - 60) + 40;
      }

      function vToY(v) {
        const ratio = (v - minV) / (maxV - minV);
        return h - 20 - ratio * (h - 40);
      }

      velCtx.clearRect(0, 0, w, h);

      velCtx.save();
      velCtx.lineWidth = 1;
      velCtx.strokeStyle = "#e5e7eb";

      const numXGrid = 10;
      const numYGrid = 6;

      velCtx.beginPath();
      for (let i = 1; i < numXGrid; i++) {
        const x = (i / numXGrid) * (w - 60) + 40;
        velCtx.moveTo(x, 0);
        velCtx.lineTo(x, h);
      }

      for (let j = 1; j < numYGrid; j++) {
        const y = (j / numYGrid) * (h - 40) + 10;
        velCtx.moveTo(0, y);
        velCtx.lineTo(w, y);
      }
      velCtx.stroke();

      velCtx.strokeStyle = "#111827";

      velCtx.beginPath();
      velCtx.moveTo(40, 0);
      velCtx.lineTo(40, h);
      velCtx.stroke();

      let zeroY;
      if (minV <= 0 && maxV >= 0) {
        zeroY = vToY(0);
      } else {
        zeroY = h - 20;
      }
      velCtx.beginPath();
      velCtx.moveTo(0, zeroY);
      velCtx.lineTo(w, zeroY);
      velCtx.stroke();

      velCtx.fillStyle = "#374151";
      velCtx.font = "10px system-ui";

      for (let t = 0; t <= timeMax; t += 2) {
        const x = tToX(t);
        velCtx.fillText(t.toString(), x - 4, h - 5);
      }

      const midV = (minV + maxV) / 2;
      const vTicks = [minV, midV, maxV];
      vTicks.forEach((v) => {
        const y = vToY(v);
        velCtx.fillText(v.toFixed(1), 4, y + 3);
      });

      velCtx.lineWidth = 2;
      velCtx.strokeStyle = "#22c55e";
      velCtx.beginPath();
      times.forEach((t, i) => {
        const x = tToX(t);
        const y = vToY(velocities[i]);
        if (i === 0) velCtx.moveTo(x, y);
        else velCtx.lineTo(x, y);
      });
      velCtx.stroke();

      velCtx.restore();
    }

    // ====== BUTTON HOOKS ======
    computeBtn.addEventListener("click", computeVelocity);
    clearBtn.addEventListener("click", clearAll);

    // ====== INITIAL DRAW ======
    drawAxes(posCtx, posCanvas);
    drawAxes(velCtx, velCanvas);
  </script>
</body>
</html>
